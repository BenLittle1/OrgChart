# OrgGraph - Organizational Maturity Assessment Tool
## Comprehensive Implementation Plan (Updated with Deployment Best Practices)

## 1. Project Vision & Core Goal
Create an intuitive, visual tool that allows founders, executives, and investors to instantly assess a company's operational maturity. The app translates a complex checklist of business processes into an interactive "living" organizational chart, providing at-a-glance understanding of progress and highlighting areas requiring attention.

## 2. Core User Experience & Flow

### Primary Workflows:
1. **"How are we doing?" (Graph View)**: Instant visual assessment with color-coded progress indicators
2. **"Let's get it done" (Checklist View)**: Task management with cascading completion logic
3. **"See the impact" (Real-time Feedback)**: Immediate visual updates across all views

### User Journey:
- User opens app → Graph View shows overall company maturity
- User navigates to Checklist → Completes specific tasks
- System provides instant feedback → Visual updates reflect progress
- Dashboard shows quantitative metrics and progress trends

## 3. Technical Architecture (Deployment-First Design)

### 3.1 Technology Stack (Stable, LTS Versions)
**CRITICAL: Always use stable, production-ready versions for reliable deployment**

- **Runtime**: Node.js 18 LTS (Alpine for Docker)
- **Framework**: Next.js 14.2.31 (NOT 15+ due to resource constraints)
- **React**: 18.2.0 (NOT 19+ due to deployment instability)
- **TypeScript**: 5.x (latest stable)
- **Styling**: Tailwind CSS 3.4.16 (NOT v4 due to breaking changes)
- **PostCSS**: 8.4.49 with autoprefixer
- **Visualization**: D3.js 7.9.0
- **Utilities**: clsx, tailwind-merge

### 3.2 Import Strategy (Deployment-Compatible)
**CRITICAL: Use relative imports, NOT TypeScript path mapping (@/)**

```typescript
// ✅ Correct (works in all environments)
import { DataContext } from '../../context/DataContext';
import { formatPercentage } from '../../lib/utils';

// ❌ Incorrect (fails in Docker builds)
import { DataContext } from '@/context/DataContext';
import { formatPercentage } from '@/lib/utils';
```

**Rationale**: TypeScript path mapping (@/) fails in containerized builds due to resolution conflicts. Relative imports work consistently across development, build, and deployment environments.

### 3.3 Project Structure (Container-Optimized)
```
src/
├── app/                    # Next.js 14 App Router
│   ├── globals.css        # Tailwind v3 imports (@tailwind directives)
│   ├── layout.tsx         # Root layout with providers
│   ├── page.tsx           # Home/overview page
│   ├── checklist/page.tsx # Task management view
│   ├── dashboard/page.tsx # Progress metrics view
│   └── graph/page.tsx     # D3.js visualization view
├── components/            # Reusable UI components
│   ├── checklist/         # Task tree components
│   ├── dashboard/         # Progress display components
│   ├── graph/             # D3.js visualization components
│   ├── layout/            # Navigation and panels
│   └── ui/                # Base UI components + ErrorBoundary
├── context/               # React Context for state management
├── lib/                   # Utilities and data processing
├── types/                 # TypeScript type definitions
└── data/                  # Static data and configuration
```

### 3.4 Configuration Files (Production-Ready)
```
next.config.js             # Use .js (NOT .ts) for Next.js 14 compatibility
tsconfig.json              # TypeScript config with relative path base
tailwind.config.js         # Tailwind v3 configuration
postcss.config.mjs         # PostCSS with autoprefixer
package.json               # Stable dependency versions
Dockerfile                 # Single-stage build for reliability
.dockerignore              # Optimized build context
railway.json               # Docker deployment configuration
```

## 4. Data Architecture & State Management

### 4.1 Core Data Structure
**Single hierarchical data object ensures consistency across all views**

```typescript
interface OrgNode {
  id: string;           // Unique identifier (e.g., "2.1.3")
  name: string;         // Display name
  isComplete: boolean;  // Completion status
  children: OrgNode[];  // Child nodes (empty for leaf tasks)
}
```

### 4.2 State Management Strategy
- **React Context** for global state (no external dependencies)
- **localStorage** persistence with hydration-safe loading
- **Immutable updates** using deep cloning
- **Cascading logic** for parent-child completion relationships

### 4.3 Business Logic (Core Algorithms)
```typescript
// Progress calculation: completed leaf nodes / total leaf nodes
const calculateProgress = (node: OrgNode): number => {
  const leafNodes = getLeafNodes(node);
  const completedLeaves = leafNodes.filter(n => n.isComplete);
  return completedLeaves.length / leafNodes.length;
};

// Node weight: 1 + sum of children weights (for visual sizing)
const calculateWeight = (node: OrgNode): number => {
  return 1 + node.children.reduce((sum, child) => sum + calculateWeight(child), 0);
};

// Color mapping: Red (0%) → Yellow (50%) → Green (100%)
const getCompletionColor = (percentage: number): string => {
  if (percentage === 0) return '#ef4444';      // red-500
  if (percentage === 1) return '#10b981';      // green-500
  return `hsl(${percentage * 120}, 70%, 50%)`; // red to green gradient
};
```

## 5. Component Architecture (Error-Resilient Design)

### 5.1 Error Boundaries (Defensive Programming)
**CRITICAL: Wrap all major components with error boundaries**

```typescript
// ErrorBoundary component prevents app crashes
<ErrorBoundary fallback={<ErrorFallback />}>
  <GraphVisualization />
</ErrorBoundary>
```

### 5.2 D3.js Integration (Container-Safe)
```typescript
// Fallback dimensions prevent crashes in container environments
const GraphVisualization = () => {
  const width = containerRect?.width || 800;   // Fallback width
  const height = containerRect?.height || 600; // Fallback height
  
  // Force simulation with memory-conscious parameters
  const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).distance(80))
    .force("charge", d3.forceManyBody().strength(-200))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .alphaDecay(0.02); // Faster settling for resource efficiency
};
```

### 5.3 Progressive Enhancement
- **Core functionality first**: Basic checklist and data persistence
- **Enhanced features second**: D3.js visualization, animations
- **Graceful degradation**: App works even if D3.js fails to load

## 6. Deployment Architecture (Production-Ready)

### 6.1 Docker Strategy (Resource-Optimized)
```dockerfile
# Single-stage build for reliability
FROM node:18-alpine

WORKDIR /app

# Environment optimization
ENV NODE_ENV=production
ENV NODE_OPTIONS="--max-old-space-size=1024"
ENV NEXT_TELEMETRY_DISABLED=1

# Install system dependencies
RUN apk add --no-cache libc6-compat

# Copy all files (maintains structure)
COPY . .

# Install dependencies
RUN npm ci --ignore-scripts --no-fund --no-audit

# Build application
RUN npm run build

# Create non-root user for security
RUN addgroup --system --gid 1001 nodejs && \
    adduser --system --uid 1001 nextjs

USER nextjs

EXPOSE 3000
CMD ["npm", "start"]
```

### 6.2 Railway Configuration
```json
{
  "build": {
    "builder": "DOCKERFILE",
    "dockerfilePath": "Dockerfile"
  },
  "deploy": {
    "healthcheckPath": "/",
    "healthcheckTimeout": 300,
    "restartPolicyType": "ON_FAILURE"
  },
  "environments": {
    "production": {
      "variables": {
        "NODE_ENV": "production",
        "NEXT_PUBLIC_APP_URL": "https://${{RAILWAY_PUBLIC_DOMAIN}}",
        "NEXT_TELEMETRY_DISABLED": "1"
      }
    }
  }
}
```

### 6.3 Build Optimization
- **Memory management**: NODE_OPTIONS with appropriate heap size
- **Dependency separation**: devDependencies vs runtime dependencies
- **Build caching**: Docker layer optimization
- **Asset optimization**: Next.js standalone output mode

## 7. Data Structure (7 Main Categories, 50+ Tasks)

### Organizational Hierarchy:
1. **Corporate & Governance** (Business formation, legal compliance, investor management)
2. **Finance & Accounting** (Financial setup, accounting processes, financial management)
3. **Human Resources** (Recruitment, onboarding, employee management)
4. **Sales & Marketing** (Strategy, online presence, lead generation)
5. **Operations & Product** (Development, supply chain, customer support)
6. **Technology & IP** (Infrastructure, intellectual property)
7. **Risk & Insurance** (Insurance management, litigation)

### Sample Data Structure:
```json
{
  "id": "root",
  "name": "My Company",
  "isComplete": false,
  "children": [
    {
      "id": "1",
      "name": "Corporate & Governance",
      "isComplete": false,
      "children": [
        {
          "id": "1.1",
          "name": "Business Formation",
          "isComplete": false,
          "children": [
            { "id": "1.1.1", "name": "Business Plan Creation", "isComplete": false, "children": [] },
            { "id": "1.1.2", "name": "Name Registration", "isComplete": false, "children": [] },
            { "id": "1.1.3", "name": "Legal Structure (LLC, Corp)", "isComplete": false, "children": [] }
          ]
        }
      ]
    }
  ]
}
```

## 8. Implementation Phases (Risk-Mitigated Approach)

### Phase 1: Core Infrastructure (Week 1)
- ✅ Set up Next.js 14 with TypeScript and stable dependencies
- ✅ Implement data structure and React Context
- ✅ Create basic layout and navigation
- ✅ Add localStorage persistence with hydration safety
- ✅ Implement error boundaries and defensive programming

### Phase 2: Essential Views (Week 2)
- ✅ Build checklist tree component with cascading logic
- ✅ Create progress dashboard with metrics
- ✅ Add basic styling with Tailwind v3
- ✅ Implement data validation and error handling

### Phase 3: Visualization (Week 3)
- ✅ Integrate D3.js force-directed graph
- ✅ Implement node sizing and coloring logic
- ✅ Add interactive controls (zoom, pan, drag)
- ✅ Create real-time synchronization between views

### Phase 4: Production Deployment (Week 4)
- ✅ Create production-ready Dockerfile
- ✅ Configure Railway deployment
- ✅ Optimize build process and resource usage
- ✅ Add comprehensive error handling and monitoring

## 9. Critical Success Factors (Lessons Learned)

### 9.1 Dependency Management
- **Use stable LTS versions** (React 18, Next.js 14, Node 18)
- **Avoid bleeding-edge releases** until thoroughly tested
- **Pin exact versions** in package.json for reproducible builds
- **Regular security updates** while maintaining stability

### 9.2 Import Strategy
- **Prefer relative imports** over TypeScript path mapping
- **Test imports in Docker environment** during development
- **Avoid complex module resolution** that fails in containers
- **Use consistent import patterns** across the codebase

### 9.3 Resource Management
- **Design for container constraints** (1GB memory limit)
- **Use NODE_OPTIONS** for heap size optimization
- **Implement progressive loading** for large datasets
- **Monitor build performance** and optimize accordingly

### 9.4 Error Handling
- **Wrap components in ErrorBoundary** to prevent cascading failures
- **Provide meaningful fallback UIs** for failed components
- **Log errors appropriately** for debugging and monitoring
- **Test error scenarios** during development

### 9.5 Build & Deployment
- **Use single-stage Docker builds** for simplicity and reliability
- **Test Docker builds locally** before deployment
- **Optimize build context** with comprehensive .dockerignore
- **Monitor deployment metrics** and resource usage

## 10. Troubleshooting Guide (Common Issues & Solutions)

### 10.1 Module Resolution Errors
**Problem**: "Can't resolve '@/context/DataContext'"
**Solution**: Replace @ imports with relative imports (../../path)

### 10.2 Build Memory Issues
**Problem**: Exit code 240, build out of memory
**Solution**: Reduce NODE_OPTIONS heap size, use stable dependencies

### 10.3 Docker Build Failures
**Problem**: Build context too large, file not found errors
**Solution**: Update .dockerignore, use COPY . . for complete structure

### 10.4 Hydration Mismatches
**Problem**: Server/client rendering differences
**Solution**: Use isLoaded state pattern for client-only features

### 10.5 D3.js Container Issues
**Problem**: Zero-width containers causing crashes
**Solution**: Implement fallback dimensions (800x600) in components

## 11. Future Enhancements (V2+ Roadmap)

### 11.1 Data Persistence
- Backend integration with PostgreSQL or MongoDB
- User authentication and multi-tenant support
- Real-time collaboration with WebSockets
- Data export/import functionality

### 11.2 Advanced Features
- Custom business process templates
- Timeline/Gantt view for project planning
- Document attachment and linking
- Advanced analytics and reporting

### 11.3 Enterprise Features
- Team management and role-based access
- API integrations with business tools
- Advanced visualization options
- Custom branding and white-labeling

## 12. Performance & Scalability Considerations

### 12.1 Frontend Optimization
- Implement virtual scrolling for large checklists
- Use React.memo() for expensive component renders
- Optimize D3.js renders with requestAnimationFrame
- Implement lazy loading for heavy components

### 12.2 Data Processing
- Cache computed values (progress calculations)
- Use Web Workers for heavy computations
- Implement efficient tree traversal algorithms
- Optimize localStorage operations

### 12.3 Bundle Optimization
- Code splitting for route-based loading
- Tree shaking for unused dependencies
- Asset optimization (images, fonts)
- Progressive Web App capabilities

---

**Key Success Metrics:**
- Application loads in <2 seconds on 3G networks
- Graph visualization handles 500+ nodes smoothly  
- Zero crashes from error boundaries
- 99.9% deployment success rate
- Sub-1GB memory usage in production

This comprehensive plan addresses the technical, deployment, and scalability challenges encountered during initial development, providing a robust foundation for reliable production deployment and future growth.